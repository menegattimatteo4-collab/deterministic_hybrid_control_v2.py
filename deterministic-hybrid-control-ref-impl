"""
Deterministic, non-collapsing hybrid control reference implementation.
Versione completa e runnable — allineata con spec v1.2
"""

import numpy as np
from scipy.integrate import solve_ivp

# ============================================================
# Parametri astratti (technology-agnostic)
# ============================================================
P_MAX = 0.5
T_MAX = 2.2
ALPHA = 0.5
B_MIN = 0.5
R_MIN = 0.95

A = 0.2
B_COEF = 0.1
GAMMA = 0.1
BETA = 0.05
QC_MAX = 0.2

DWELL_TIME = 0.5  # [s]

# ============================================================
# Stati discreti
# ============================================================
OFF, STARTUP, NOMINAL, DEGRADED, SAFE = range(5)

STATE_NAME = {
    OFF: "OFF",
    STARTUP: "STARTUP",
    NOMINAL: "NOMINAL",
    DEGRADED: "DEGRADED",
    SAFE: "SAFE",
}

# ============================================================
# Dinamiche continue x = [P, T, dT, B, Qc, r]
# ============================================================
def dynamics(t, x, state):
    P, T, dT, B, Qc, r = x

    if state == NOMINAL:
        dP   = 0.0
        dTdt = A * P - B_COEF * Qc
        dB   = -GAMMA * P
        dr   = 0.0

    elif state == DEGRADED:
        dP   = -BETA * P
        dTdt = A * P - B_COEF * Qc
        dB   = -GAMMA * P
        dr   = -0.01

    elif state == SAFE:
        dP   = 0.0
        dTdt = -B_COEF * QC_MAX
        dB   = 0.0
        dr   = 0.0

    else:  # OFF / STARTUP
        dP = dTdt = dB = dr = 0.0

    return [dP, dTdt, dT, dB, Qc, dr]  # ˙dT = 0 → dT costante

# ============================================================
# Eventi gi(x) >= 0
# ============================================================
def g_T(t, x):   return x[1] - T_MAX
def g_dT(t, x):  return x[2] - ALPHA
def g_P(t, x):   return x[0] - P_MAX
def g_B(t, x):   return B_MIN - x[3]
def g_r(t, x):   return R_MIN - x[5]

EVENTS = [g_T, g_dT, g_P, g_B, g_r]

for ev in EVENTS:
    ev.terminal = True
    ev.direction = 1

# ============================================================
# Logica di transizione deterministica con priorità
# ============================================================
def next_state(current, active):
    g1, g2, g3, g4, g6 = active

    if g1 or g2 or g6:              # Priorità assoluta: SAFE
        return SAFE

    if current == NOMINAL and (g3 or g4):
        return DEGRADED

    if current == DEGRADED and (g1 or g2 or g6):
        return SAFE

    return current

# ============================================================
# Simulazione ibrida
# ============================================================
def simulate(Tf=50.0, verbose=True):
    x = np.array([0.4, 1.8, 0.0, 1.0, 0.0, 1.0])
    state = NOMINAL
    t = 0.0
    last_switch = -1e9

    if verbose:
        print("=== Inizio simulazione ===")
        print(f"Stato iniziale: {STATE_NAME[state]} | x = {x}")

    while t < Tf:
        sol = solve_ivp(
            lambda tt, yy: dynamics(tt, yy, state),
            [t, Tf],
            x,
            events=EVENTS,
            max_step=0.1,
            rtol=1e-6,
            atol=1e-8,
        )

        t = sol.t[-1]
        x = sol.y[:, -1]

        if sol.status != 1:
            if verbose:
                print(f"t = {t:.2f} | Nessun evento ulteriore.")
            break

        active = [ev(t, x) >= 0 for ev in EVENTS]
        new_state = next_state(state, active)

        if (t - last_switch) >= DWELL_TIME and new_state != state:
            if verbose:
                print(f"t = {t:.2f} | Eventi: {active} → {STATE_NAME[state]} → {STATE_NAME[new_state]}")
            state = new_state
            last_switch = t

            if state == SAFE:
                x[0] = 0.0
                if verbose:
                    print("SAFE raggiunto. P forzato a 0.")
                break

    if verbose:
        print("=== Fine ===")
        print(f"Stato finale: {STATE_NAME[state]} | t = {t:.2f}")
        print(f"x finale = {x}")

    return state, x

if __name__ == "__main__":
    simulate(Tf=1000.0)
